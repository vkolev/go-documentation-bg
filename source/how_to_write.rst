Как да пишете Go код
####################

Въведение
=========

Този документ обяснява как да пишете нов пакет и как да тествате код. Приема, че сте инсталирали Go използвайки 
инструкциите за инсталация: :doc:`install/index`.

Преди да се впуснете в промяна на съществуващ пакет или в създаването на нов, изпратете писмо до 
`пощенския списък <http://groups.google.com/group/golang-nuts>`_, за да уведомите хората за това какво мислите да
направите. По този начин помагате за избягване на дупликиране на опита и позволява дискусия относно дизайна
преди да бъде написан какъвто и да е код.

Ресурси на общността
====================

За помощ в реално време, може да има потребители или разработчици в #go-nuts на 
`Freenode <http://freenode.net/>`_ IRC сървъра.

Официялният ощенски списък за дискусии относно Go езика е `Go Nuts <http://groups.google.com/group/golang-nuts>`_.

Грешки можете да съобщавате в `тракера за грешки на Go <http://code.google.com/p/go/issues/list>`_.

За онези, които искат да са в крак с разработката, съществува отделен пощенски списък,
`golang-checkins <http://groups.google.com/group/golang-checkins>`_, който получава съобщение, обобщаващо всяка 
промяна в Go хранилището.

Създаване на нов пакет
======================

Избиране на път за вмъкване
---------------------------

Стандартните пакети имат кратки имена като ``fmt`` и ``net/http`` за удобство. За вашите лични проекти, избирайте
име, което е малко вероятно да влезе в конфликт с бъдещи добавки към стандартната библиотека или други външни
библиотеки.

На пример, ако вашето хранилище на кода се намира на адрес ``example.com`` или ``code.google.com/p/example``, можете
да започнете пътищата на пакета с този адрес, като в ``example.com/foo/bar`` или ``code.google.com/p/example/foo/bar``.
По този начин `go инструмента <http://weekly.golang.org/cmd/go/>`_ може автоматично да изтегли и построи изходния код
от този път.

Ако нямате намерение кодът ви да бъде инсталиран по този начин, би трябвало да използвате уникален префикс като 
``widgets/``, както в ``widgets/foo/bar``. Добро правило е да използвате за префикс името на вашата фирма или проект,
тъй като е малко вероятно то да бъде използвано от друга група.

``go`` инструмента и GOPATH
---------------------------

`Go инструмента <http://weekly.golang.org/cmd/go/>`_ е стандартното средставо за компилиране и инсталиране на Go 
библиотеки и програми. Той е инструмент с "нулева конфигурация"; определя как да компилира Go пакети само от техния
изходен код.

За да използвате ``go`` инструмента ефикасно трябва да зададете ``GOPATH`` променлива. ``GOPATH`` определя списък
с пътища съдържащи Go изходен код и бинарни пакети. Изходен код, пакетирани обекти и изпълними команди се намират
в ``GOPATH``-пътища съотвено: ``src``, ``pkg``, и ``bin``.

Трябва да зададете ``GOPATH`` във профила на вашия шел (:file:`$HOME/.bashrc`, :file:`$HOME/.profile` или еквивалент)

Тази шел сесия демонстрира задаването на ``GOPATH``, създаване на тривиален ``widgets/foo`` пакет, компилиране и инсталиране на самия пакет.

.. code-block:: console

    $ export GOPATH=$HOME/gocode
    $ mkdir -p $GOPATH/src/widgets/foo
    $ cat > $GOPATH/src/widgets/foo/foo.go
    package foo
    const String = "Go rules!"
    ^D
    $ go install widgets/foo
    $ ls $GOPATH/pkg/*/widgets
    foo.a

**

.. note:: ``^D`` означава натискане на :kbd:`Control-D`

Въведете ``go help gopath`` в командния ред за повече информация относно ``GOPATH``.

Go изходни файлове
------------------

Първата заявка в изходния код на Go файл би трябвало да бъде ``package <name>``, където ``<name>`` е името по 
подразбиране за пакета за вмъкване (``import``). (Всички файлове в пакета трябва да използват същото ``<name>``). Go
конвенция е, че имената на пакетите са последния елемент от пътя за вмъкване: пакетът вмъкнато като "``crypto/rot13``"
трябва да се казва ``rot13``. Няма изискване имената на пакетите да са уникални между всичи пакети свързаи в един 
изпълним, достатъчно е пътищата за вмъкване (техните пълни имена) да са уникални.

Go компилира всички изходни файлове от пакет наведнъж, така един файл може да референсира константи, променливи,
типове и функции в друг файл, без специални условия или декларации.

Писането на чист, идоматичен Go код е извън предмета на този документ. :doc:`effective_go` прдставлява изложение по 
тази тематика.

Построяване на програми
=======================

``go`` инструмента третира кода принадлежащ към ``package main`` като изпълним, и инсталира изпълнимия пакет в 
``$GOPATH/bin`` директорията.

Построяването на изпълними команди е същото като построяването на пакети. Използвайте "``go install``"

.. code-block:: console

    $ mkdir -p $GOPATH/src/widgets/bar
    $ cat > $GOPATH/src/widgets/bar/bar.go
    package main

    import (
        "fmt"
        "widgets/foo"
    )

    func main() {
        fmt.Println(foo.String)
    }
    ^D
    $ go install widgets/bar
    $ $GOPATH/bin/bar
    Go rules!

Изпълнете ``go help build`` и ``go help install`` за повече информация относно построяване и инсталиране на изпълними
файлове/пакети в Go.

Тестване
========

Go разполага с лека ремка за тестване, композирана от ``go`` инструмента и пакета ``testing``. Можете да напишете
тест като създадете файл с име завършващо на ``_testing.go``, което съдържа функции с имена ``TestingXX`` и вид
``func (t *testing T)``. Тестовата рамка изпълнява всяка функция; ако функцията извика провалена функция с ``t.Error``
или ``t.Fail``, тестът се смята за провален. Изпълнете ``go help test`` и прегледайте `документацията на пакета testing <http://weekly.golang.org/pkg/testing/>`_ за повече информация.

За да стартирате теста, изпълнете ``go test``:

.. code-block:: console

    $ cat > $GOPATH/src/widgets/foo/foo_test.go
    package foo

    import "testing"

    func TestString(t *testing.T) {
        const expect = "Go rules!"
        if String != expect {
            t.Errorf("String == %q, want %q", String, expect)
        }
    }
    ^D
    $ go test widgets/foo
    ok  	widgets/foo	0.018s

**

Ако вашата промяна е свързана с производителността, добавете Banchmark функция (изпълнете ``go help testfunc``) и 
изпълнете ``go test -test.bech=.*``

Примерен пакет с тестове
========================

Този примерен пакет, ``numbers``, се състои от функция ``Double``, която приема ``int`` и връща стойността умножена
по 2. Състои се от два файла.

Първо, пакетната имплементация, ``numbers.go``:

.. code-block:: go

    package numbers

    func Double(i int) int {
	    return i * 2
    }

Следва тестът, ``numbers_test.go``:

.. code-block:: go

    package numbers

    import (
	    "testing"
    )

    type doubleTest struct {
	    in, out int
    }

    var doubleTests = []doubleTest{
	    doubleTest{1, 2},
	    doubleTest{2, 4},
	    doubleTest{-5, -10},
    }

    func TestDouble(t *testing.T) {
	    for _, dt := range doubleTests {
		    v := Double(dt.in)
		    if v != dt.out {
			    t.Errorf("Double(%d) = %d, want %d.", dt.in, v, dt.out)
		    }
	    }
    }

**

Изпълнявайки ``go install`` ще построи и инсталира пакета в ``$GOPATH/pkg`` директоряита (след което може да бъде 
вмъкнат от всяка друга Go програма)

Изпълнявайки ``go test`` ще постои отново пакета, включително и ``numbers_test.go`` файла и след това ще изпълни
функцията ``TestDouble``. Изходът ``ok`` показва, че всички тестове са преминали успешно. Счупвайки имплементацията
като промените множителя от 2 на 3 ще ви позволи да видите как изглеждат съобщенията при неуспешен тест.

Изпълнете ``go help test``, ``go help testfunc`` и ``go help testflag`` и вижте 
`документацията на пакета testing <http://weekly.golang.org/pkg/testing/>`_ за повече информация.

Архитектурен и специфичен за операционната система код
======================================================

Първо едно опровержение: много малко Go пакети трябва да знаят относно хардуера и операционната система, на която 
се изпълняват. В общия случай езикът и стандартната библиотека обработват повечето проблеми със съвместимостта.
Тази секция е съвет за по-напреднали системни програмисти, които имат добра причина да пишат платформено-специфичен
код, като поддръжка на асемблиран език за бързи тригонометрични функции или код, който имплементира общ интерфейс
над различни операционни системи.

За да компилирате такъв код, използвайте ``$GOOS`` и ``$GOARCH`` променливи на средата в имената на файловете на
вашия изходен код.

На пример приемете пакета ``foo``, който би се състоял от следните четири файла:

.. code-block:: console

    foo.go
    foo_386.go
    foo_amd64.go
    foo_arm.go

По този начин се описва пакета, който трябва да се построи на различните архитектури с ``$GOARCH`` като 
параметър в името на файла.

Основния код отива в ``foo.go``, докато специфичня за архитектурата код съответно в ``foo_386.go``, 
``foo_amd64.go`` и ``foo_arm.go``.

Ако използвате тази конвенция в имената на файловете, инструменти като ``go`` инструмента ще работят без проблеми
с вашия пакет:

.. code-block:: console

    foo_$GOOS.go
    foo_$GOARCH.go
    foo_$GOOS_$GOARCH.go

Същото важи за ``.s`` (асембъл) и ``.c`` файлове.
