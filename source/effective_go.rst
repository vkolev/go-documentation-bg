Ефективен Go
############

Въведение
=========

Go е нов език. Въпреки, че взаимства идеи от съществуващи езици, разполага с необикновни възможности, които правят ефективните
Go програми различни като характер от програми написани на неговите подобни езици. Директен превод на програми писани на C++ 
или Java в Go е необичайно да създаде очакван резултат - Java програмите са написани на Java, не на Go. От друга страна
мислейки за проблема през погледа на Go може да създаде успешна, но доста различна програма. С други думи, за да пишете добре
Go е важно да разберете неговите свойства и идиоми. Също така е важно да познавате отвърдените конвенции за програмиране на Go,
като именуване, форматиране, програмна конструкция и т.н., така че програмите, които пишете да бъдат лесни за разбиране от други
Go програмисти.

Този доумент дава съвети за писане на чист и идоматичен Go код. Това е надстройка на 
`езиковата спецификация <http://weekly.golang.org/doc/go_spec.html>`_ и :doc:`go_tutorial`, които би трябвало да прочетете първи.

Примери
-------

`Изходния код на Go пакетите <http://weekly.golang.org/src/pkg/>`_ има за цел да представи не само стандартната библиотека, но и да
послужи за пример как да използвате езика. Ако имате въпрос относно как да подходите към проблем или как нещо може да бъде 
имплементирано, те могат да предоставят отговори, идеи и основи.

Форматиране
===========

Проблемите с форматирането са най-спорни, но и най-маловажни. Хората могат да се адаптират към различни стилове на форматиране, но е
най-добре ако не им се налага и се отделя по-малко време по темата дали всички се придържат към същия стил. Проблемът е как да се 
подходи към тази утопия без установен наръчник за стила.

С Go ние подхващаме необикновен подход и оставяме машината да се заеме с повечето проблеми на форматирането. Програмата ``gofmt``
(също така достъпна от ``go tool fmt``, която оперира на ниво пакет, вместо на ниво изходен код) чете Go програмата и обръща 
изходния код в стандартния стил на абзаци и вертиално подреждане, запазвайки и, ако е необходимо, преформатирайки коментарите.
Ако искате да разберете как да се справите с някоя нова ситуция относно подредбата, стартирайте ``gofmt``; ако отговорът не 
изглежда правилен, преподредете своята програма (или изпратете съобщение за грешка относно ``gofmt``), не работете около тази
ситуация.

Като пример, не е необходимо да отделяте време в изравняване на коментарите за полетата на някоя структура. ``Gofmt`` ще 
направи това за вас. Взимайки следната декларация:

.. code-block:: go

    type T struct {
        name string // name of the object
        value int // its value
    }

``gofmt`` ще изравни колоните:

.. code-block:: go

    type T struct {
        name    string // name of the object
        value   int    // its value
    }

Всичкия Go код в стандартните пакети е форматиран с ``gofmt``.

Някой особености на форматирането остават. На кратко,

*Отстояние*
    Използваме :kbd:`<Tab>` за отстояние и ``gofmt`` го използва по подразбиране. Използвайте шпации само ако е необходимо

*Дължина на реда*
    Go няма ограничение за дължината на реда. Не се притеснявайте ако редът излиза от монитора. Ако усещате, че това е грешно
    продължете на нов ред и добавете допълнителен таб.

*Скоби*
    Go се нуждае от няколко скоби: контролни структури (``if, for, switch``) нямат скоби в техния синтаксис. Също така йерархията
    на операторните процедури е по-кратка и ясна, така
    
.. code-block:: go

    x<<8 + y<<16

означава това, което празните места оперделят.

Коментари
=========

Go предоставя C-подобни ``/* ... */`` блок-коментари и C++-подобни ``//`` редови коментари. Редовите коментари са нормата; блоковите
коментари се използват най-често като коментари в пакети и са удобни за коментиране на големи част от код.

Програмата - и уеб-сървър - ``godoc`` обработва Go изходни файлове, за да извлече документация относно съдържанието на пакета. Коментари
които се появяват преди декларации от горно ниво, без намесата на нови редове, се извличат заедно с декларацията за да служат като 
обяснителен текст към тях. Природата и стила на тези коментари определя качетвото на документацията, която ``godoc`` предоставя.

Вески пакет би трябвало да има и *пакетен коментар*, блоков коментар преди пакентната клауза. За пакети с повече файлове, пакетния коментар
е необходимо да просъства в един файл, без значение кой. Пакетния коментар трябва да представя пакета и да предоставя информация
свързана с пакета като цяло. Този текст ще се появява първоначално на ``godoc`` страницата и ще настройва
детайлната документация, която следва.

.. code-block:: go

    /*
        Package regexp implements a simple library for
        regular expressions.

        The syntax of the regular expressions accepted is:

        regexp:
            concatenation { '|' concatenation }
        concatenation:
            { closure }
        closure:
            term [ '*' | '+' | '?' ]
        term:
            '^'
            '$'
            '.'
            character
            '[' [ '^' ] character-ranges ']'
            '(' regexp ')'
    */
    package regexp

**

Ако пакетът е прост, пакетният коментар може да бъде кратък.

.. code-block:: go

    // Package path implements utility routines for
    // manipulating slash-separated filename paths.

Коментарите не се нуждаят от допълнително форматиране като банери от звезди. Генерираният текст, дори може да не бъде представен с
желания шрифт, за това не разчитайте на отстъпи за форматиране - ``godoc``, както ``gofmt`` се заема с това. Коментарите са
неинтерпретиран чист тест, така че HTML и други маркери като ``__this__`` ще създават ``курсив текст`` и не би трябвало да бъдат
използвани. В зависимост от контекста, ``godoc`` може изобщо да не форматира коментарите, така че се уверете, че те изглеждат 
добре от начало: използвайте правилен език, пунктуация, и подредба на изреченията, разбивайте дълги редове и т.н.

В пакет, всеки коментар, след който следва декларация от високо ниво служи като *док. коментар* за тази декларация. Всяко 
изнесено (с главна буква) име в програмата трябва да има документационен коментар.

Документационните коментари служат най-добре като цели изречения, което позволява широк спектър от възможности за автоматизирани
презентации. Първото изречение - трябва да е обобщение в едно изречение, което започва с името, което бива декларирано.

.. code-block:: go

    // Compile parses a regular expression and returns, if successful, a Regexp
    // object that can be used to match against text.
    func Compile(str string) (regexp *Regexp, err error) {

**

Декларационния синтаксис на Go позволява групиране на декларации. Единичен документационен коментар, може да представи група от 
свързани константи или променливи. Тъй като цялата декларация е представена, такъв коментар може често да бъде повърхностен.

.. code-block:: go

    // Error codes returned by failures to parse an expression.
    var (
        ErrInternal      = errors.New("regexp: internal error")
        ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
        ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
        ...
    )

Дори при лични имена, групирането може да индикира връзки между елементите, като например че група от променливи е защитена от
мутекс.

.. code-block:: go

    var (
        countLock   sync.Mutex
        inputCount  uint32
        outputCount uint32
        errorCount  uint32
    )


Имена
=====


Имена на пакети
---------------


Getters
-------


Имена на интерфейси
-------------------


Миксирани главни
----------------


Точки и запетаи
===============


Контролни структури
===================

If
--


Предеклариране
--------------


For
---


Switch
------


Функции
=======


