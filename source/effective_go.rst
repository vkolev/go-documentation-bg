Ефективен Go
############

Въведение
=========

Go е нов език. Въпреки, че взаимства идеи от съществуващи езици, разполага с необикновни възможности, които правят ефективните
Go програми различни като характер от програми написани на неговите подобни езици. Директен превод на програми писани на C++ 
или Java в Go е необичайно да създаде очакван резултат - Java програмите са написани на Java, не на Go. От друга страна
мислейки за проблема през погледа на Go може да създаде успешна, но доста различна програма. С други думи, за да пишете добре
Go е важно да разберете неговите свойства и идиоми. Също така е важно да познавате отвърдените конвенции за програмиране на Go,
като именуване, форматиране, програмна конструкция и т.н., така че програмите, които пишете да бъдат лесни за разбиране от други
Go програмисти.

Този доумент дава съвети за писане на чист и идоматичен Go код. Това е надстройка на 
`езиковата спецификация <http://weekly.golang.org/doc/go_spec.html>`_ и :doc:`go_tutorial`, които би трябвало да прочетете първи.

Примери
-------

`Изходния код на Go пакетите <http://weekly.golang.org/src/pkg/>`_ има за цел да представи не само стандартната библиотека, но и да
послужи за пример как да използвате езика. Ако имате въпрос относно как да подходите към проблем или как нещо може да бъде 
имплементирано, те могат да предоставят отговори, идеи и основи.

Форматиране
===========

Проблемите с форматирането са най-спорни, но и най-маловажни. Хората могат да се адаптират към различни стилове на форматиране, но е
най-добре ако не им се налага и се отделя по-малко време по темата дали всички се придържат към същия стил. Проблемът е как да се 
подходи към тази утопия без установен наръчник за стила.

С Go ние подхващаме необикновен подход и оставяме машината да се заеме с повечето проблеми на форматирането. Програмата ``gofmt``
(също така достъпна от ``go tool fmt``, която оперира на ниво пакет, вместо на ниво изходен код) чете Go програмата и обръща 
изходния код в стандартния стил на абзаци и вертиално подреждане, запазвайки и, ако е необходимо, преформатирайки коментарите.
Ако искате да разберете как да се справите с някоя нова ситуция относно подредбата, стартирайте ``gofmt``; ако отговорът не 
изглежда правилен, преподредете своята програма (или изпратете съобщение за грешка относно ``gofmt``), не работете около тази
ситуация.

Като пример, не е необходимо да отделяте време в изравняване на коментарите за полетата на някоя структура. ``Gofmt`` ще 
направи това за вас. Взимайки следната декларация:

.. code-block:: go

    type T struct {
        name string // name of the object
        value int // its value
    }

``gofmt`` ще изравни колоните:

.. code-block:: go

    type T struct {
        name    string // name of the object
        value   int    // its value
    }

Всичкия Go код в стандартните пакети е форматиран с ``gofmt``.

Някой особености на форматирането остават. На кратко,

*Отстояние*
    Използваме :kbd:`<Tab>` за отстояние и ``gofmt`` го използва по подразбиране. Използвайте шпации само ако е необходимо

*Дължина на реда*
    Go няма ограничение за дължината на реда. Не се притеснявайте ако редът излиза от монитора. Ако усещате, че това е грешно
    продължете на нов ред и добавете допълнителен таб.

*Скоби*
    Go се нуждае от няколко скоби: контролни структури (``if, for, switch``) нямат скоби в техния синтаксис. Също така йерархията
    на операторните процедури е по-кратка и ясна, така
    
.. code-block:: go

    x<<8 + y<<16

означава това, което празните места оперделят.

Коментари
=========

Go предоставя C-подобни ``/* ... */`` блок-коментари и C++-подобни ``//`` редови коментари. Редовите коментари са нормата; блоковите
коментари се използват най-често като коментари в пакети и са удобни за коментиране на големи част от код.

Програмата - и уеб-сървър - ``godoc`` обработва Go изходни файлове, за да извлече документация относно съдържанието на пакета. Коментари
които се появяват преди декларации от горно ниво, без намесата на нови редове, се извличат заедно с декларацията за да служат като 
обяснителен текст към тях. Природата и стила на тези коментари определя качетвото на документацията, която ``godoc`` предоставя.

Вески пакет би трябвало да има и *пакетен коментар*, блоков коментар преди пакентната клауза. За пакети с повече файлове, пакетния коментар
е необходимо да просъства в един файл, без значение кой. Пакетния коментар трябва да представя пакета и да предоставя информация
свързана с пакета като цяло. Този текст ще се появява първоначално на ``godoc`` страницата и ще настройва
детайлната документация, която следва.

.. code-block:: go

    /*
        Package regexp implements a simple library for
        regular expressions.

        The syntax of the regular expressions accepted is:

        regexp:
            concatenation { '|' concatenation }
        concatenation:
            { closure }
        closure:
            term [ '*' | '+' | '?' ]
        term:
            '^'
            '$'
            '.'
            character
            '[' [ '^' ] character-ranges ']'
            '(' regexp ')'
    */
    package regexp

**

Ако пакетът е прост, пакетният коментар може да бъде кратък.

.. code-block:: go

    // Package path implements utility routines for
    // manipulating slash-separated filename paths.

Коментарите не се нуждаят от допълнително форматиране като банери от звезди. Генерираният текст, дори може да не бъде представен с
желания шрифт, за това не разчитайте на отстъпи за форматиране - ``godoc``, както ``gofmt`` се заема с това. Коментарите са
неинтерпретиран чист тест, така че HTML и други маркери като ``__this__`` ще създават ``курсив текст`` и не би трябвало да бъдат
използвани. В зависимост от контекста, ``godoc`` може изобщо да не форматира коментарите, така че се уверете, че те изглеждат 
добре от начало: използвайте правилен език, пунктуация, и подредба на изреченията, разбивайте дълги редове и т.н.

В пакет, всеки коментар, след който следва декларация от високо ниво служи като *док. коментар* за тази декларация. Всяко 
изнесено (с главна буква) име в програмата трябва да има документационен коментар.

Документационните коментари служат най-добре като цели изречения, което позволява широк спектър от възможности за автоматизирани
презентации. Първото изречение - трябва да е обобщение в едно изречение, което започва с името, което бива декларирано.

.. code-block:: go

    // Compile parses a regular expression and returns, if successful, a Regexp
    // object that can be used to match against text.
    func Compile(str string) (regexp *Regexp, err error) {

**

Декларационния синтаксис на Go позволява групиране на декларации. Единичен документационен коментар, може да представи група от 
свързани константи или променливи. Тъй като цялата декларация е представена, такъв коментар може често да бъде повърхностен.

.. code-block:: go

    // Error codes returned by failures to parse an expression.
    var (
        ErrInternal      = errors.New("regexp: internal error")
        ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
        ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
        ...
    )

Дори при лични имена, групирането може да индикира връзки между елементите, като например че група от променливи е защитена от
мутекс.

.. code-block:: go

    var (
        countLock   sync.Mutex
        inputCount  uint32
        outputCount uint32
        errorCount  uint32
    )


Имена
=====

Имената са важни в Go, както във всеки друг програмен език. В някои случаи имат дори семантичен ефект: на пример,
видимостта на име извън пакет се определя от това дали първата буква е главна. Поради тази причина има смисъл
да отделим малко време на конвенциите за именуване в Go програми.

Имена на пакети
---------------

Когато се вмъква пакет, името на пакета става връзка към съдържанието. След

.. code-block:: go
    
    import "bytes"

вмъкването пакета може да говори за ``bytes.Buffer``. От помощ е ако всеки, който използва пакета може да използва
същото име за обръщане към неговото съдържание, което изисква името на пакета да бъде добро: кратко, сбито,
ясно. Според конвенцията пакетите трябва да бъдат задавани с малки букви, имена от една дума; не трябва да има нужда
от използване на долна черта или миксираниГлавни. Не се осланяйте на мимолетността, тъй като всеки, който използва
вашият пакет, ще трябва да пише името му. И не се притеснявайте за противоречия *a priori*. Името на пакета е само
името по подразбиране, което да се използва за вмъкване; не се изисква да бъде униклано за целия изходен код, и в 
случай на противоречие за вмкъквания пакет, може да бъде избрано друго име, което да се използва локално. При 
всички случаи, объркването е рядко тъй като името на файла във вмъкването определея само кой пакет да бъде 
използван.

Друга конвенция е, че името на пакета е основното име на директорията на кода; пакета в 
:file:`src/pkg/encoding/base64` се вмъква като ``"encoding/base64"``, но има име ``base64``, а не ``encoding_base64``
или ``encodingBase64``.

Вмъкващият пакета ще използва името за да се обърне към съдържанието (Нотацията ``import .`` е предвидена преди
всички за тестове и други нестандартни ситуации и би трябвало да бъде избягване, освен ако не се налага), така че
експортирани имена в пакета могат да използват този факт, за да избегнат пелтечене. За пример, типът на 
буферният четец в ``bufio`` пакета е наречен ``Reader``, не ``BufReader``, тъй като потребителите го виждат като 
``bufio.Reader``, което е ясно, съдържателно име. Още повече, тъй като импортираните имена винаги биват адресирани
с името на пакета, ``bufio.Reader`` не е в конфликт с ``io.Reader``. Подобно, функцията за правене на нови 
инстанции на ``ring.Ring`` - което е дефиницията на *конструктор* в Go - обикновено ще бъде наречена ``NewRing``, но
тъй като ``Ring`` е само тип, изнесен от пакета и тъй като пакета е наречен ``ring``, тя е наречена просто ``New``, 
което клиентите четат като ``ring.New``. Използвайте пакетната структура, за да изберете добри имена.

Друг кратък пример е ``once.Do``, ``once.Do(setup)``, което се чете добре и не би било подобрено от писане на
``once.DoOrWaitUntilDone(setup)``. Дългите имена не правят автоматично нещата по-четими. Ако името представлява 
нещо заплетено или объркващо, обикновено е по-добре да напишете упътващ doc коментар вместо да се опитвате
да поставите всичката информация в името.

Getters
-------

Go не предлага автоматична поддръжка за getter-и и setter-и. Няма нищо грешно в това да предоставите getter-и или
setter-и сами, а често и така е по-правилно, но не е идиоматично или необходимо да слагате ``Get`` в името на 
getter-а. Ако имате поле ``owner`` (с малки букви, не-експортирано), getter метода ще бъде наречен ``Owner``
(главни буква в началото, експортирано), не ``GetOwner``. Използването на имена с главни букви за експортиране,
предоставя връзка за

Имена на интерфейси
-------------------


Миксирани главни
----------------


Точки и запетаи
===============


Контролни структури
===================

If
--


Предеклариране
--------------


For
---


Switch
------


Функции
=======


