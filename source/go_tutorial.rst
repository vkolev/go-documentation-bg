Въведение в програмния език Go
##############################


Предговор
=========

Този документ е урок представящ основите на програмния език Go, предвиден за програмисти, запознати с C или C++. 
Това не е подробен наръчник за езика; до този момент най-близкия документ до това е `спецификацията на езика <http://weekly.golang.org/doc/go_spec.html>`_. 
След като прочетете този урок, можете да продължите с `Ефективен Go <http://weekly.golang.org/doc/effective_go.html>`_, който навлиза по-дълбоко в 
това как се използва езика и говори за стил и идиоми при програмирането с Go. Съществува и интерактивна интродукция в Go, наречена `Разходка в Go <http://tour.golang.org/>`_.

Презентацията тук преминава през серия от най-скромни програми, за да илюстрира основните особености на езика. Всички програми
работят (в момента на писане) и са качени в хранилището в директория `/doc/progs/ <http://weekly.golang.org/doc/progs>`_.

Здравей свят
============

Нека започнем по обичайния начин:

.. code-block:: go

    package main

    mport fmt "fmt" // Пакет имплементиращ форматиран I/O.

    func main() {
        fmt.Printf("Здравей свят!; или Καλημέρα κόσμε; или こんにちは 世界\n")
    }

Всеки файл с изходен код в Go, използвайки ``package`` изявлението, което показва към кой пакет принадлежи. Също така може да вмъква други пакети, за да 
използва техните удобства. Тази програма вмъква пакета ``fmt``, за да добие достъп до нашия стар, сега с главна буква и пакетиран приятел, ``fmt.Printf``.

Функциите се представят с ключовата дума ``func``. Функцията ``main`` в пакета ``main`` е мястото, където програмата се изпълнява (след всяко стартиране).

Низови константи могат да съдържат уникод символи, кодирани в UTF-8. (Всъщност, изходните файлове на Go по дефиниця са кодирани в UTF-8)

Конвенцията за писането на кометари е същата като при C++.

По-късно ще споменем повече относно принтирането.

Точки и запетаи
===============

Може би сте забелязали, че в нашата програма няма точки и запетаи. В Go кода, единственото място в което вероятно ще използвате точки и запетаи е при
разграничаването на клаузите във ``for`` цикъл и подобни; не са необходими след всяка заявка.

Всъщност това, което се случва е, че формалният език използва точки и запетаи, както в C или Java, но те се добавят автоматично в края на всеки ред, който
изглежда като край на заявка. Не е необходимо да ги въвеждате.

За подробности как е направено това, можете да погледнете спецификацията на езика, но за практиката всичко, което трябва да знаете е, че никога няма да потребява
да слагате точки и запетаи в края на ред. (Можете да ги поставяте ако искате да напишете няколко заявки на един ред). Като допълнителна помощ можете да
поставяте точка и запетая веднага преди затварянето на скоба.

Този подход спомага за код, който няма точки и запетаи и изглежда добре. Единствената изненада е, че е важно да поставяте отварящата къдрава скоба на конструктор
като ``if`` на същия ред, на който е ``if``; ако не направите това, съществуват ситуации, в които кода няма да се компилира или ще даде грешен резултат. Езикът
налага този стил на къдрави скови до известна степен.

Компилиране
===========

Go е компилируем език. В момента същствуват два компилатора: ``Gccgo`` е Go компилатор, който използва за основа GCC. Има и пакет от компилатори с различни (и странни)
имена за всяка архитектура: ``6g`` за 64-bit x86, 8g за 32-bit x86 и други. Тези компилатори работят значително по-бързо, но генерират по-малко ефикасен код, в
сравнение с ``gccgo``. В момента на писане (края на 2009), те имат и по-стабилна run-time система, въпреки, че gccgo наваксва.

Ето как да компилираме и изпълним нашата програма. С 6g, казваме:

.. code-block:: console

    $ 6g helloworld.go  # компилира; обекта отива в helloworld.6
    $ 6l helloworld.6   # линкер; изходът отива в 6.out
    $ ./6.out
    Здравей свят!; или Καλημέρα κόσμε; или こんにちは 世界
    $

С ``gccgo`` това изглежда малко по-традиционно:

.. code-block:: console

    $ gccgo helloworld.go
    $ ./a.out
    Здравей свят!; или Καλημέρα κόσμε; или こんにちは 世界
    $

Echo
====

Подред, това е версия на Unix инструмента ``echo(1)``:

.. code-block:: go

    package main

    import (
        "flag" // четец за опции в командния ред
        "os"
    )

    var omitNewline = flag.Bool("n", false, "не разпечатвай последния нов ред")

    const (
        Space   = " "
        Newline = "\n"
    )

    func main() {
        flag.Parse() // Сканира списъка с аргументи и задава флагове
        var s string = ""
        for i := 0; i < flag.NArg(); i++ {
            if i > 0 {
                s += Space
            }
            s += flag.Arg(i)
        }
        if !*omitNewline {
            s += Newline
        }
        os.Stdout.WriteString(s)
    }

Тази програма е малка, но прави много нови неща. В последния пример видяхме, че ``func`` представя функция. 
Ключовите думи ``var``, ``const`` и ``type`` (не е използвана още) също представляват декларации, както и import.
Забележете, че можем да групираме декларации от еднакъв тип в списъци, един елемент на ред, както ``import`` и 
``const`` клаузите тук. Но не е задължително да се прави; бихме могли да кажем

.. code-block:: go

    const Space = " "
    const Newline = "\n"

Тази програма вмъква "os" пакета, за да има достъп до неговата ``Stdout`` променливата, от тип  ``*os.File``.
Заявката ``import`` е всъщност декларация: в своята основна форма, както е използвана в нашата "здравей свят" програма.
Именува идентификатора (``fmt``), който ще бъде използван за достъп до членовете на пакета вмъкнат от (``"fmt"``)
файла, който може да бъде намерен в настоящата директория или в стандартната локация. В тази програма, обаче, ние
изпускаме изричното име от вмъкването; по подразбиране пакетите се вмъкват, използвайки име дефинирано от вмъквания
пакет, което по условие е самото име на файла. Нашата "здравей свят" програма, можеше просто да казва 
``import "fmt"``.

Можете да определяте собствени имена за вмъквания ако поискате, но това е необходимо само ако искате да избегнете
конфликт с именуване.

Имайки ``os.Stdout``, можем да използваме неговия ``WriteString`` метод, за да принтираме низа.

След като вмъкнем ``flag`` пакета, можем да използваме ``var`` декларацията, за да инициализираме глобална променлива,
наречена ``omitNewline``, която да съдържа стойността на ``-n`` флага на echo. Променливата е от тип ``*bool``, 
показател към ``bool``.

В ``main.main`` правим разбор на аргументите (извикването на ``flag.Parse``) и след това създаваме локална низова
променлива, с която да създадем изхода.

Декларационната заявка има формата

.. code-block:: go
    
    var s string = ""

Това е ключовата дума ``var``, последвана от името на променливата, последвана от нейния тип, последван от знакът
равно и първоначалната стойност на променливата.

Go се опитва да бъде сбит и тази декларация може да бъде съкратена. Тъй като низовата константа е от тип низ, не е
необходимо да казваме това на компилатора. Можем да напишем:

.. code-block:: go

    var s = ""

Дори можем да бъдем още по-кратки, използвайки идиома

.. code-block:: go

    s := ""

Операторът ``:=`` се използва много често в Go, за да представи инициализираща декларация. Има такъв в следващия
ред във ``for`` клаузата:

.. code-block:: go

    for i := 0; i < flag.NArg(); i++ {

Пакетът ``flag`` е направил разбор на аргументите и е поставил не-flag аргументите в списък, който може да бъде
обходем по очевидия начин.

Заявката ``for`` в Go се различава от тази в C по много причини. Първо, това е единствения цикъл, няма ``while`` или
``do``. Второ, няма скоби в клаузата, но къдравите скоби в тялото са задължителни. Същото важи и за ``if`` и 
``switch`` заявките. По-късни примери ще покажат други начини как може да бъде написан ``for`` цикъл.

Тялото на цикъла попълва низът ``s``, добавяйки (използвайки ``+=``) аргументите и отделящите шпации. След цикъла, ако
``-n`` флагът липсва, програмата добавя нов ред. Накрая изписва резултата.

Забележете, че ``main.main`` е функция без аргументи. Дефинирана е по този начин. Стигайки краят на ``main.main``
означава "успех"; ако искате да сигнализирате грешен изход можете да извикате

.. code-block:: go

    os.Exit(1)

Пакетът ``os`` съдържа и други съществени елементи; на пример, ``os.Args`` е част, използвана от ``flag`` пакета за
достъп до аргументите в командния ред.

Антракт относно типове
======================

Go има някои познати типове като ``int`` и ``uint`` (unsigned int), които представляват стойности от "посходящ" размер
за машината. Също така дефинира и изрично-ограничени типове като ``int8``, ``float64`` и т.н., плюс неподписани типове
като ``uint``, ``uint32`` и други. Това са различни типове, дори ако ``int`` и ``int32`` са с размер от 32 бита, те
са различни типове. Същестува и ``byte`` синоним за ``uint8``, който е тип елемент за низове.

Типове с плаваща запетая са винаги оразмерени: ``float32`` и ``float64``, плюс ``complex64`` (два ``float32``) и 
``complex128`` (два ``float64``). Комплексните числа са извън предмета на урока.

Говорейки за ``string``, това също е вграден тип. Низовете са *неизменими променливи* - те не са просто масиви от
``byte`` стойности. След като веднъж сте построили низова *стойност*, можете да я промените, въпреки че, разбира се, 
можете да промените низова *променлива* като просто я превъзложите. Изрезката код от ``strings.go`` е легален код:

.. code-block:: go

    s := "hello"
    if s[1] != 'e' {
        os.Exit(1)
    }
    s = "good bye"
    var p *string = &s
    *p = "ciao"

Обаче следните заявки са нелегални, защото ще променят ``string`` стойността:

.. code-block:: go

    s[0] = 'x'
    (*p)[1] = 'y'

Според C++ определението, низовете в Go са като ``const strings``, докато показателите към низовете са аналогични на
референции към ``const string``.

Да има показатели. Въпреки това Go опростява тяхното използване; прочетете нататък.

Масивите се декларират така:

.. code-block:: go

    var arrayOfInt [10]int

Масивите, както низовете, са стойности, но те са непостоянни. Това се различава от C, където arrayOfInt ще бъде 
използван като показател към ``int``. В Go, тъй като масивите са стойности, е смислено (и полезно) да се говори
за показатели към масиви.

Размерът на масива е част от неговия тип; въпреки това е допустимо да се декларира *изрязана* променлива, която да 
съдържа референция към който и да е масив, от всякакъв размер, със същия тип елементи. *Изрязващ израз* има
формата ``a[low : high]``, представляващ вътрешен масив, индексиран от ``low`` до ``high-1``; крайната изрезка 
е индексирана от 0 до ``high-low-1``. На кратко, изрезките приличат на масиви, но нямат изричен размер(``[]`` срещу
``[10]``) и те представят сегмент от подстоящия, обикновено анонимен, нормален масив. многобройи изрезки могат
да споделят данни ако представляват един и същи масив; многобройни масиви не могат никога да споделят данни.

Изрезките са по-често срещани в Go, отколкото нормални масиви; те са по-гъвкави, имат семантични връзки и са 
ефективни. Това което им липсва е прецизния контрол на макет за записване както при обикновените масиви; ако
искате да имате стотина елемента от масив записвани във вашата структура, трябва да използвате нормален масив.
За да създадете такъв, използвайте *конструктор* на съединителна стойност - израз формиран от типа, следван от израз
ограден в къдрави скоби както в следния пример:

.. code-block:: go

    [3]int{1,2,3}

В този случай конструктора създава масив от 3 цифри (``int``).

Когато подавате масив към функция, почти винаги ще искате да декларирате формалния параметър като изрезка. Когато
извикате функцията, изрежете масива, за да създадете (ефикасна) свързана изрезка и подайте нея. По подразбиране
горния и долния край на изрезка отговарят на краищата на съществуващия обект, така сбитата нотация ``[:]`` ще
изреже целия масив:

.. code-block:: go

    func sum(a []int) int { // връща число
        s := 0
        for i := 0; i < len(a); i++ {
            s += a[i]
        }
        return s
    }

Забележете как типът (int) на връщаната стойност бива дефиниран за ``sum``, заявявайки го след списъка с параметри.

За да извикаме функцията, изрязваме масива. Този код (ще покажем по-просто начин след малко) създава масив и го 
изрязва:

.. code-block:: go

    x := [3]int{1,2,3}
    s := sum(x[:])

Ако създавате обикновен масив, но искате компилатора да преброи елементите за вас, използвайте ``...`` като размер
на масива.

.. code-block:: go

    x := [...]int{1,2,3}
    s := sum(x[:])

Но това е по-объркано от необходимото. В практиката, освен ако не сте педантични относно начина на записване в
структурата от данни, изрезката сама - използвайки празни скоби без размер - е всичко, от което се нуждаете:

.. code-block:: go

    s := sum([]int{1,2,3})

Съществуват също така и карти, които могат да бъдат инициализирани така:

.. code-block:: go

    m := map[string]int{"one":1, "two":2}

Вградената функция ``len``, която връща броят елементи, се появява за първи път в ``sum``. Работи над низове, масиви,
изрезки, карти и канали.

Между другото друго нещо, което работи над низове, масиви, изрезки, карти и канали е ``range`` клаузата в ``for``
цикли. Вместо да пишете

.. code-block:: go

    for i := 0; i < len(a); i++ { ... }

за да обходите елементите на изрезка (или карта, или ...) можете да напишете:

.. code-block:: go

    for i, v := range(a) { ... }

Това задава ``i`` към индексът и ``v`` към стойността на следващите елемнти от целта на обхвата. 
Виж :doc:`effective_go` за повече примери.

Антракт относно алокация
========================

Повечето типове в Go са стойности. Ако имате ``int`` или ``struct`` или някакъв масив, предаването копира съдържанието
на обекта. За да разпределите нова променлива, използвайте вградената функция ``new``, която връща показател
към разпределеното хранилище.

.. code-block:: go

    type T struct { a, b int}
    var t \*T = new(T)

или по-идиоматичното

.. code-block:: go

    t := new(T)

Някои типове - карти, изрезки и канали (виж по-долу) - имат свързана семантика. Ако държите изрезка или карта и искате
да промените техното съдържание, други променливи, които референсират същите данни ще видят промяната. За тези три
типа искате да използвате вградената функция, ``make``:

.. code-block:: go

    m := make(map[string]int)

Тази заявка инициализира нова карта, готова да съдържа елементи. Ако просто декларирате картата, какво в

.. code-block:: go

    var m map[string]int

създава ``nil`` референция, която не може да съдържа нищо. За да използвате картата, първо трябва да инициализирате
връзката, използвайки ``make`` или като зададате вече съществуваща карта.

Забележете, че ``new(T)`` връща тип ``*T``, докато ``make(T)`` връща тип ``T``. Ако (по погрешка) разпределите свързан
обект с ``new`` вместо ``make``, ще получите показател към ``nil`` връзка, еквивалентно на това да декларирате
неинициализирана променлива и да вземете нейния адрес.

Антракт към константи
=====================


